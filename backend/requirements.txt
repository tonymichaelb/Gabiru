fastapi==0.115.6
uvicorn[standard]==0.32.1






























































































    return username        )            headers={"WWW-Authenticate": "Bearer"},            detail="Could not validate credentials",            status_code=status.HTTP_401_UNAUTHORIZED,        raise HTTPException(    if username is None:    username = decode_access_token(token)    token = credentials.credentials    """Dependency to get current authenticated user from JWT token."""async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:        return None    except JWTError:        return username            return None        if username is None:        username: str = payload.get("sub")        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])    try:    """Decode and validate JWT token, return username if valid."""def decode_access_token(token: str) -> Optional[str]:    return encoded_jwt    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)    to_encode.update({"exp": expire})        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)    else:        expire = datetime.utcnow() + expires_delta    if expires_delta:    to_encode = data.copy()    """Create a JWT access token."""def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:    return pwd_context.hash(password)    """Hash a password for storing."""def get_password_hash(password: str) -> str:    return pwd_context.verify(plain_password, hashed_password)    """Verify a password against its hash."""def verify_password(plain_password: str, hashed_password: str) -> bool:    token_type: str = "bearer"    access_token: strclass Token(BaseModel):    password: str    username: strclass UserLogin(BaseModel):    password_confirm: str    password: str    username: strclass UserCreate(BaseModel):    created_at: str    hashed_password: str    username: strclass User(BaseModel):security = HTTPBearer()# HTTP Bearer token schemepwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")# Password hashingACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7  # 7 daysALGORITHM = "HS256"SECRET_KEY = os.getenv("CHROMA_SECRET_KEY", secrets.token_urlsafe(32))# JWT Configurationfrom pydantic import BaseModelfrom passlib.context import CryptContextfrom jose import JWTError, jwtfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentialsfrom fastapi import Depends, HTTPException, statusfrom typing import Optionalfrom datetime import datetime, timedeltaimport secretsimport os"""Handles user registration, login, and JWT token management.pyserial==3.5
pydantic==2.10.4
python-multipart==0.0.20
passlib[bcrypt]==1.7.4
python-jose[cryptography]==3.3.0
